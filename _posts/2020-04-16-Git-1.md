---
layout: post
categories: [Git]
---

## Всякие первоначальные настройки репозитория

- **Задание юзернейма и адреса электронной почты:**

  ```bash
  git config --global user.name "poppyfanboy"
  git config --global user.email "whatever@email.com"
  ```

- **Достать текущие конфигурации:**

  ```bash
  git config --get user.name
  git config --get user.email
  # вот такая штука ещё выводит фаел, из которого берутся конкретные конфиги
  git config --list --show-origin
  ```

  У конфигов есть уровни (system, global, local), каждый следующий переопределяет предыдущий:

  - `system` — конфиги для всех пользователей, хранятся в `/etc/gitconfig`
  - `global` — конфиги для текущего пользователя, хранятся в домашней папке (например, в `~/.gitconfig`)
  - `local` — конфиги для текущего репозитория, хранятся в `./.git/config`

- **Задать дефолтный текстовый редактор:**

  ```bash
  git config --global core.editor vim
  ```

  Для других текстовых редакторов там может быть всё сложнее и вообще неочевидно, придётся гуглить отдельно. Но для таких целей вима будет более, чем достаточно.

- **Создание SSH-ключа:**

  ```bash
  ssh-keygen -t rsa -b 4096 -C "whatever@email.com"
  ```

- **Как создать репозиторий и сделать push в удалённый репозиторий на гитхабе:**

  ```bash
  git init
  # *создать фаелы проекта*
  git add .
  git commit -m "Initial commit"
  # или можно https://github.com/poppyfanboy/tetris-game.git
  git remote add origin git@github.com:poppyfanboy/tetris-game.git
  git push origin master
  ```

----

<br>

##  About Version Control

**Система контроля версий** (version control system, VCS) — это штука, которая запоминает изменения, сделанные в наборе файлов, запоминает, кто и когда сделал изменения, так что разные версии проекта можно было сравнить, вернуться к предыдущим версиям, или смерджить некоторые типы файлов.

В частности эта штука полезна в командной работе, например, когда кто-то занимается исправлением багов, а кто-то одновременно с этим добавляет какие-то новые фичи, так что нужно поддерживать две версии одного проекта. Ну и ещё можно ограничивать возможность изменения каких-то файлов проекта.

**Виды VCS:**

- **Local VCS** — все изменения сохраняются локально.
- **Centralized VCS** — есть отдельный сервер под VCS. Это упрощает работу в команде, позволяет ввести контроль над тем, кто что может делать в проекте. **Минусы** в том, что если сервер упадёт, то вся работа остановится, и ещё вроде как ветвление сложнее, потому что серверу придётся постоянно поддерживать кучу веток, а в DVCS ветки изначально могут быть локальными и потом они сливаются с мастером.
- **Distributed VCS** — каждый клиент делает полную копию проекта и работает с ней. **Плюс** в том, что все изменения локальны, можно работать без подключения к серверу (в том числе доступна вся история изменений проекта) и потом запушить свои изменения, нет задержки при работе с удалёнными файлами. **Минус** в том, что если, например, в проекте много больших бинарных файлов, которые плохо сжимаются, то потребуется много места для хранения проекта локально.

Обычно VCS хранят изменения между файлами, а не сами файлы разных версий, чтобы не надо было хранить несколько одинаковых копий одного файла. Такое называется **delta-based version control**. А когда для каждой версии хранится отдельный полный набор фаелов (кроме тех, что повторяются полностью, повторяющиеся хранятся только в одном месте и следующие снапшоты просто ссылаются на них), то это называется **snapshot-based version control**.

Последовательность изменений можно представить в виде направленного ацикличного дерева: узлы — это отдельные **revisions** проекта, они упорядочены в порядке внесения изменений. Выделяется **trunk** или **mainline** дерева, который соответствует мастеру в гите, от него могут отходить ветки, которые потом могут сливаться с главной веткой. **HEAD** — это текущий конец главного ствола дерева. **Baseline**, **tag**, **label** — это всё одно и то же, это способ пометить какие-то отдельные снапшоты как наиболее важные (какой-то стабильный релиз или ещё что-то такое). **Check out** — создание рабочей копии, **check in** — наоборот, то же самое, что и коммит, внесение изменений.

![](https://upload.wikimedia.org/wikipedia/commons/a/af/Revision_controlled_project_visualization-2010-24-02.svg)

Файлы в гите идентифицируются во SHA-1 хешу, с помощью него же обнаруживаются все внесённые изменения. Файлы в гит-проекте могут находиться в одном из трёх состояний (modified, staged, commited):

- **modified** — фаел был изменён, но изменения ещё не были закоммичены
- **staged** — это просто означает, что файл был помечен для того, чтобы войти в следующий коммит. Совокупность всех таких файлов — это **staging area**.
- **commited** — это уже, когда изменения были внесены в локальную базу данных

----

<br>

## Git Basics

**git clone.** Я не знаю, почему, но у меня эта штука сначала, когда я использовал HTTPS URL, попросила авторизоваться с юзернеймом и паролем, и не дала склонировать чужой репозиторий. А когда я попробовал SSH URL, то всё спокойно склонировалось и с HTTPS URL проблем больше тоже не было. Так что, видимо, SSH URL — это предпочтительный вариант тут.

Эта команда тупо всё копирует, все снапшоты, всё-всё.

`git clone git@github.com:username/repository.git`

----

Помимо modified/staged/commited состояний файлы ещё могут быть **tracked** и **untracked**. Untracked — это фаелы, которые не были включены в последний коммит, то есть те, которые были созданы вот прямо сейчас. Tracked файлы — соответственно, фаелы, которые в последнем коммите есть. Из состояния untracked файлы сразу попадают в staged, после чего в commited.

----

**Short status.** Оказывается, в дурацком и громоздком `git status` есть флаг `-s` или `--short`, который выводит всё в более кратком виде:

```bash
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt

# ? - untracked
# A - added to the staging area (из untracked в staging area)
# M - modified
```

При этом состояния файлов выводятся в два столбца: в первом — состояние файла в staging area, во втором — состояние в working directory. То есть`MM` означает, что файл изменили, добавили в некст коммит, а потом снова изменили. Или, например, `AM` — файл создали, добавили в коммит, а потом изменили.

**Нормальный git diff.** Кстати, оказывается, ещё помимо тупого неудобного `git diff` есть

```bash
$ git difftool [--staged] --tool=vimdiff
```

Который красиво всё выводит side-to-side в виме. А простой `git diff` всё выводит тупо и непонятно вообще. И я ещё не знал, что `git diff` выводит всё, что ещё не было staged, а `git diff --staged` наоборот — всё, что было staged.

**Skipping staging area.** Можно тупо добавить флаг `-a` при коммите, чтобы все изменения сами автоматически добавились.

----

<br>

### Ignoring Files

Ну, понятно, что это всё делается в `.gitignore`, но я не знал, что можно иметь дополнительные `.gitignore` в поддиректориях, которые переписывают правила, определённые в глобальном `.gitignore` в корне репозитория. А ещё можно использовать вот такие штуки:

- Если в начале указать `/`, то он не будет игнорировать рекурсивно то, что идёт после слеша, а только то, что видно из текущей директории. Ну, то есть, если написать `bin/`, то он будет игнорить все папки с таким названием, а если `/bin/`, то только одну папку в корне.
- Если в начале указать `!`, то это добавит паттерн в исключение. Так что можно, например, заигнорить все jpg-картинки, кроме какой-то одной.
- А ещё тут работают **glob patterns** — это такие упрощённые регулярные выражения специально для названий файлов и папок. Так что тут можно писать штуки вроде `[abc]`, `*?`, `[a-zA-Z][0-9]`. При этом `*` никак не взаимодействует со штуками в квадратных скобках, это просто нисколько или сколько-то произвольных символов.
- А ещё есть `**` — это любые поддиректории. То есть вот такое `a/**/*.pdf` заигнорит все pdf-файлы в любых поддиректориях папки `a`.

