---
layout: post
author: PoppyFanboy
---

## What are Threads

----

*14.1–14.2 в первой книжке core java*

* *общие штуки, чем отличаются потоки от процессов, как запустить новый поток, как прервать поток, почему не стоит использовать `Thread.stop()`, как справляться с `InterruptedException`*

----

<br>

**Общие штуки.** Операционная система выделяет куски ЦПУ-времени для каждого запущенного процесса, тем самым создавая впечатление того, что всё работает параллельно, так что количество "одновременно" работающих процессов не ограничено количеством процессоров (ядер). По аналогии внутри одной программы может быть создано несколько **потоков** (**thread**), которые будут выполняться одновременно. Programs that can rum more than one thread at once are said to be **multithreaded**.

**Процессы и потоки.** Разница между несколькими *процессами* и *потоками* в том, что каждый процесс имеет свой отдельный набор переменных (данных), в то время как потоки разделяют между собой одни и те же данные. **Плюс общих данных** в том, что это делает взаимодействие между потоками более эффективным, **минус** в том, что всё становится немного сложнее и непредсказуемее, придётся синхронизировать ресурсы, используемые совместно.

**Как запустить новый поток.** Необходимость в многопоточности возникает в самых простых случаях: например, когда надо прерывать выполнение какого-нибудь затратного по времени процесса, а не ждать его завершения. Чтобы запустить код в отдельном потоке достаточно просто создать объект класса `Thread`, передав ему код, который надо запустить через функциональный интерфейс `Runnable` (лямбда выражением просто можно). И после этого надо будет вызвать `thread.start()`. Раньше было принято также наследовать свой класс от `Thread`, в котором переопределять метод `run()`, так что бы достаточно просто было написать `new MyThread().run()` для запуска нового потока. Однако такой подход не рекомендуется, потому что каждый раз выделять новый поток на каждую задачу — слишком жирно, **надо разделять задачи, которые требуется выполнить, и механизм для их выполнения**.

**Прерывание потоков.** Поток может завершиться естественным образом, если происходит возвращение из запущенного метода `run()`, или, когда там выбрасывается неперехваченное исключение. Можно также использовать метод `Thread.stop()` из другого потока, однако сейчас этот метод устарел:

> This method is inherently unsafe. Stopping a thread with `Thread.stop` causes it to unlock all of the monitors that it has locked (as a natural consequence of the unchecked `ThreadDeath` exception propagating up the stack).  If any of the objects previously protected by these monitors were in an inconsistent state, the damaged objects become visible to other threads, potentially resulting in arbitrary behavior. Many uses of `stop` should be replaced by code that simply modifies some variable to indicate that the target thread should stop running. The target thread should check this variable regularly, and return from its run method in an orderly fashion if the variable indicates that it is to stop running. If the target thread waits for long periods (on a condition variable,       for example), the `interrupt` method should be used to interrupt the wait.

Однако, кроме `Thread.stop()` нет другого способа насильно завершить поток, разве что вызвать `Thread.interrup()`, чтобы *запросить* завершение треда. Это выставляет флаг внутри потока, переводя его в *interrupted status*. `Thread.currentThread()` — чтобы получить доступ к текущему потоку, `curentThread.isInterrupted()` — чтобы проверить, не был ли прерыван тред. (Есть ещё статический метод `interrupted`, который возвращает флаг для текущего потока, и сразу же его сбрасывает в `false`.) Однако, если поток заблокирован (например, если у него вызвали `sleep` или `wait`), то у него просто нет шанса на то, чтобы завершиться. Поэтому в таком случае выбрасывается `InterruptedException` (это checked exception, так что пользователь обязан корректно его перехватить).

Нет чёткого никакого требования на уровне ЯП касательно того, когда  "прерванный" поток должен завершиться, прерывание — это просто указание на то, что потоку надо бы завершиться. 

**Handling `InterruptedException`.** Не стоит писать штук вроде:

```java
try {
    sleep(100);
} catch (InterruptedException e) { }
```

Даже, если ничего не получается придумать, то всегда есть выбор из вот такимх универсальных вариантов:

- Можно проглотить исключение и всё-таки выставить флаг через `Thread.currentThread().interrupt()`.
- А можно просто перебросить исключение выше по иерархии, указав `throws InterruptedException` в объявлении метода.

<br>

<br>

## Thread States

----

*14.3 в первой книжке core java*

----

<br>

**Состояния потока.** Потоки могут быть в одном из следующих состояний:

- New
- Runnable
- Blocked
- Waiting
- Timed waiting
- Terminated

Для определения текущего состояния достаточно вызвать `Thread.getState()`, который вернёт `Thread.State`.

**New threads.** Это начальное состояние потоков, с которым они создаются. В этом состоянии они ещё не запущены.

**Runnable Threads.** Как только был вызван метод `start`, поток становится *runnable*. При этом он необязательно выполняется прямо конкретно сейчас, он может быть на паузе, пока выполняются другие потоки, но операционная система может дать ему шанс немного поработать. Операционная система опирается на определённый список приоритетов (которые будут обсуждены несколько позже), когда выбирает, какой поток возобновить следующим. Такой вариант распределения ресурсов между потоками называется **preemptive scheduling** ([ссылка на краткое описание](https://www.geeksforgeeks.org/preemptive-and-non-preemptive-scheduling/)).

